
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Landscape to Play in the Dark - Shivering Sea</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

  </head>
  <body>

    <div id="container"></div>

    <script src="js/three.min.js"></script>

    <script src="js/FPSThree.js"></script>

    <script src="js/ImprovedNoise.js"></script>

    <script src="js/dancerJS/dancer.js"></script>

    <script>

    //Classes

      var Cube = function(v,l){

        this.v = v;
        this.l = l;
        this.cube;
        this.dirX = 0;
        this.dirY = 0;
        this.dirZ = 0;
        this.vitesse = 1*Math.random();
        this.rand = 0;

        this.setDir();

      }
      Cube.prototype.create = function(){
        var b = true;
      
        var rand = Math.random();

        this.cube = new THREE.Mesh(new THREE.CubeGeometry(this.l, this.l, this.l), new THREE.MeshBasicMaterial());
        this.cube.position = this.v;
        scene.add(this.cube);
      }
      Cube.prototype.setDir = function(){

        var rand = Math.random();
        var dir = 0;
        if(rand > 0.5){
          dir = 1;
        }
        else if (rand < 0.5){
          dir = -1;
        }

        rand = Math.random();

        if(rand > 0 && rand < 0.3){
          this.dirX = dir;
        }
        else if(rand > 0.3 && rand < 0.6){
          this.dirY = dir;
        }
        else if(rand > 0.6 && rand < 1){
          this.dirZ = dir;
        }

      }

      Cube.prototype.checkGround = function(){

        var minX = this.cube.position.x;
        var maxX = this.cube.position.x + this.l;
        var minY = this.cube.position.y;
        var maxY = this.cube.position.y + this.l;
        var minZ = this.cube.position.z;
        var maxZ = this.cube.position.z + this.l;

        for(var i = 0; i < tabCubes.length; i++){
          if(minX > tabCubes[i].cube.position.x && maxX < tabCubes[i].cube.position.x + tabCubes[i].l &&
          minY > tabCubes[i].cube.position.y && maxY < tabCubes[i].cube.position.y + tabCubes[i].l &&
          minZ > tabCubes[i].cube.position.z && maxZ < tabCubes[i].cube.position.z + tabCubes[i].l){
            this.dirX = -this.dirX;
            this.dirY = -this.dirY;
            this.dirZ = -this.dirZ;
          }
        }

      }


      Cube.prototype.update = function(){

        var xRand = Math.random();
        var yRand = Math.random();
        var zRand = Math.random();
            var yRand = Math.random();
            if(xRand < 0.5){xRand = this.cube.position.x -this.rand;
            }else{xRand = this.cube.position.x + this.rand;}
            if(yRand < 0.5){yRand = this.cube.position.y -this.rand;}
            else{yRand = this.cube.position.y + this.rand;}
            if(zRand < 0.5){zRand = this.cube.position.z -this.rand;
            }else{zRand = this.cube.position.z + this.rand;}
            this.cube.position.x = xRand;
            this.cube.position.y = yRand;
            this.cube.position.z = zRand;

            this.cube.position.x += this.dirX*this.vitesse;
            this.cube.position.y += this.dirY*this.vitesse;
            this.cube.position.z += this.dirZ*this.vitesse;

            this.checkGround();

  };

      var camera, controls, scene, renderer;

      var mesh, texture;

      var worldWidth = 256, worldDepth = 256,
      worldHalfWidth = worldWidth / 2, worldHalfDepth = worldDepth / 2;

      var clock = new THREE.Clock();

      var tabZonesSacres = new Array();
      var tabCubes = new Array();
      var tabTab = new Array();

      init();
      animate();

      function init() {
        container = document.getElementById( 'container' );
        camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 10000 );
        camera.position.y = 500;
        controls = new THREE.FirstPersonControls( camera );
        controls.movementSpeed = 50;
        controls.lookSpeed = 0.05;

        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2( 0x000000, 0.0009 );
        // add subtle blue ambient lighting

        //var data = generateHeight( worldWidth, worldDepth );
        createMap(worldWidth - 1, worldDepth - 1);

        renderer = new THREE.WebGLRenderer( { alpha: false } );
        renderer.setClearColor( 0x000000 );
        renderer.setSize( window.innerWidth, window.innerHeight );

        container.innerHTML = "";

        container.appendChild( renderer.domElement );

        //

        window.addEventListener( 'resize', onWindowResize, false );

      }



      function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

      }

      function generateHeightPerso(){
        var size = width * height;

      }

      function generateHeight( width, height) {

        var size = width * height, data = new Float32Array( size ),
        perlin = new ImprovedNoise(), quality = 1, z = Math.random() * 1;
        for ( var i = 0; i < size; i ++ ) {

          data[ i ] = 0

        }
        for ( var j = 0; j < 4; j ++ ) {

          for ( var i = 0; i < size; i ++ ) {

            var x = i % width, y = ~~ ( i / width );
            data[ i ] += Math.abs( perlin.noise( x / quality, y / quality, z ) * quality * 1.75 );
          }

          quality *= 5;

        }

        return data;

      }

      function createMap(w,d){
        var geometry = new THREE.PlaneGeometry( 7500, 7500, w - 1, d - 1 );
        var invertedGeometry = new THREE.PlaneGeometry( 7500, 7500, w - 1, d - 1 );
        geometry.applyMatrix( new THREE.Matrix4().makeRotationX(  Math.PI / 2 ) );
        invertedGeometry.applyMatrix( new THREE.Matrix4().makeRotationX(  -Math.PI / 2 ) );

        for ( var i = 0, l = geometry.vertices.length; i < l; i ++ ) {

          geometry.vertices[ i ].y = Math.random()*-500;
          invertedGeometry.vertices[ i ].y = Math.random()*500;

        }

        mesh = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial() );
        invertedMesh = new THREE.Mesh( invertedGeometry, new THREE.MeshBasicMaterial() );
        mesh.position.y = 2000;
        invertedMesh.position.y = 2000;
        scene.add( mesh );
        //scene.add( invertedMesh );

      }


      var createMengerSpong = function(origin,length,iteration){
            tabCubes[tabCubes.length] = new Cube(origin,length);
            tabCubes[tabCubes.length-1].create();
           
            iteration--;
            if(iteration >= 0){

            
              createMengerSpong(new THREE.Vector3(origin.x,origin.y+length+length,origin.z),length*Math.random(),iteration);
              createMengerSpong(new THREE.Vector3(origin.x,origin.y+length*2+length*2,origin.z),length*Math.random(),iteration);
              createMengerSpong(new THREE.Vector3(origin.x,origin.y+length*2+length*2,origin.z+length+length),length*Math.random(),iteration);
              createMengerSpong(new THREE.Vector3(origin.x,origin.y+length*2+length*2,origin.z+length*2+length*2),length*Math.random(),iteration);
              createMengerSpong(new THREE.Vector3(origin.x+length+length,origin.y+length*2+length*2,origin.z),length*Math.random(),iteration);
              createMengerSpong(new THREE.Vector3(origin.x+length*2+length*2,origin.y+length*2+length*2,origin.z),length*Math.random(),iteration);
              createMengerSpong(new THREE.Vector3(origin.x+length*2+length*2,origin.y+length*2+length*2,origin.z+length*2+length*2),length*Math.random(),iteration);

              createMengerSpong(new THREE.Vector3(origin.x,origin.y,origin.z+length+length),length*Math.random(),iteration);
              createMengerSpong(new THREE.Vector3(origin.x,origin.y,origin.z+length*2+length*2),length*Math.random(),iteration);
              createMengerSpong(new THREE.Vector3(origin.x+length+length,origin.y,origin.z+length*2+length*2),length*Math.random(),iteration);
              createMengerSpong(new THREE.Vector3(origin.x+length*2+length*2,origin.y,origin.z+length*2+length*2),length*Math.random(),iteration);
              createMengerSpong(new THREE.Vector3(origin.x,origin.y+length+length,origin.z+length*2+length*2),length*Math.random(),iteration);
              createMengerSpong(new THREE.Vector3(origin.x+length+length,origin.y+length*2+length*2,origin.z+length*2+length*2),length*Math.random(),iteration);

              createMengerSpong(new THREE.Vector3(origin.x+length+length,origin.y,origin.z),length*Math.random(),iteration);
              createMengerSpong(new THREE.Vector3(origin.x+length*2+length*2,origin.y,origin.z),length*Math.random(),iteration);
              createMengerSpong(new THREE.Vector3(origin.x+length*2+length*2,origin.y+length+length,origin.z),length*Math.random(),iteration);
              createMengerSpong(new THREE.Vector3(origin.x+length*2+length*2,origin.y+length*2+length*2,origin.z+length+length),length*Math.random(),iteration);
              createMengerSpong(new THREE.Vector3(origin.x+length*2+length*2,origin.y,origin.z+length+length),length*Math.random(),iteration);
              createMengerSpong(new THREE.Vector3(origin.x+length*2+length*2,origin.y+length+length,origin.z+length*2+length*2),length*Math.random(),iteration);
            }
        }
         createMengerSpong(new THREE.Vector3(0,0,0),500,2);
         //createMengerSpong(new THREE.Vector3(0,0,0),500,2);
         //createMengerSpong(new THREE.Vector3(0,0,0),500,2);

    //Dancer

    var dancer = new Dancer();
    var a = new Audio();
    a.src = 'music/areYouShivering.mp3';
    dancer.load(a);
    dancer.play();
    dancer.setVolume(0.5);

      function animate() {

        requestAnimationFrame( animate );
        render();

      }

      setInterval(function(){
        for(var i = 0; i < tabCubes.length; i ++){
          tabCubes[i].update();
          camera.position.y -= 0.001;
          //directionalLight.lightIntensity = 1;
          //directionalLight.position = new THREE.Vector3(camera.position.x + 20, camera.position.y, camera.position.z);
        }
      },10)


      function render() {

        controls.update( clock.getDelta() );
        renderer.render( scene, camera );

      }

      

    </script>

  </body>
</html>
